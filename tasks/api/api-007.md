---
id: api-007
title: pgvector similarity search API
status: todo
priority: high
tags:
- api
- search
- vectors
dependencies:
- backend-028
assignee: developer
created: 2026-02-15T12:43:36.005901329Z
estimate: 2h
complexity: 5
area: api
---

# pgvector similarity search API

## Causation Chain
> Trace the request lifecycle: HTTP verb → middleware chain → handler →
service → data layer → response serialization. Verify actual route
registration and middleware order in code.

## Pre-flight Checks
- [ ] Read dependency task files for implementation context (Session Handoff)
- [ ] `grep -r "route\|path\|endpoint" src/` - Verify route registration
- [ ] Check actual middleware order in router setup
- [ ] Verify response serialization matches API contract
- [ ] `git log --oneline -10` - Check recent related commits

## Context
Implement RESTful API endpoints for pgvector similarity search over encrypted embeddings. These endpoints integrate with backend-028's PgVectorClient to provide semantic search capabilities while maintaining Shield's EXPTIME encryption. Supports storing AI embeddings (OpenAI, Cohere, custom models) and performing nearest neighbor search on encrypted data.

**Use cases**: RAG systems, semantic search, recommendation engines, duplicate detection.

**Dependency on backend-028**: Requires PgVectorClient, EncryptedVector, and VectorStore implementations.

## Tasks
- [ ] Design API contract (OpenAPI 3.0 schema)
- [ ] Implement Python FastAPI endpoints:
  - [ ] `POST /vectors` - Insert vector with metadata
  - [ ] `POST /vectors/batch` - Batch insert (up to 1000 vectors)
  - [ ] `POST /vectors/search` - Similarity search
  - [ ] `GET /vectors/{id}` - Retrieve vector by ID
  - [ ] `PUT /vectors/{id}` - Update vector and metadata
  - [ ] `DELETE /vectors/{id}` - Delete vector
  - [ ] `GET /vectors/stats` - Collection statistics
- [ ] Add request/response models with Pydantic
- [ ] Add authentication (Shield token or API key)
- [ ] Add pagination for search results
- [ ] Add filtering by metadata (JSONB queries)
- [ ] Add vector validation (dimension, range checks)
- [ ] Add OpenAPI documentation
- [ ] Add integration tests with PostgreSQL
- [ ] Build + test with pytest

## Acceptance Criteria
- [ ] All 7 endpoints implemented and documented
- [ ] OpenAPI schema generated and validated
- [ ] Vector insertion encrypts data correctly
- [ ] Similarity search returns accurate results
- [ ] Search results properly decrypted
- [ ] Authentication required for all endpoints
- [ ] Pagination works (cursor-based)
- [ ] Metadata filtering works with JSONB operators
- [ ] Batch operations handle errors gracefully
- [ ] Integration tests pass (minimum 18 tests)

## Notes

### API Contract (OpenAPI 3.0)
```yaml
openapi: 3.0.0
info:
  title: Shield pgvector API
  version: 1.2.0
paths:
  /vectors:
    post:
      summary: Insert encrypted vector
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                vector:
                  type: array
                  items: { type: number }
                  minItems: 1
                  maxItems: 4096
                metadata:
                  type: object
                  additionalProperties: true
      responses:
        '201':
          description: Vector inserted
          content:
            application/json:
              schema:
                type: object
                properties:
                  id: { type: integer }
                  created_at: { type: string, format: date-time }

  /vectors/batch:
    post:
      summary: Batch insert vectors
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                vectors:
                  type: array
                  minItems: 1
                  maxItems: 1000
                  items:
                    type: object
                    properties:
                      vector: { type: array, items: { type: number } }
                      metadata: { type: object }
      responses:
        '201':
          description: Vectors inserted
          content:
            application/json:
              schema:
                type: object
                properties:
                  inserted: { type: integer }
                  ids: { type: array, items: { type: integer } }

  /vectors/search:
    post:
      summary: Similarity search
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                query:
                  type: array
                  items: { type: number }
                limit:
                  type: integer
                  minimum: 1
                  maximum: 100
                  default: 10
                metric:
                  type: string
                  enum: [l2, cosine, inner_product]
                  default: cosine
                filter:
                  type: object
                  description: JSONB filter (e.g., {"category": "product"})
      responses:
        '200':
          description: Search results
          content:
            application/json:
              schema:
                type: object
                properties:
                  results:
                    type: array
                    items:
                      type: object
                      properties:
                        id: { type: integer }
                        vector: { type: array, items: { type: number } }
                        metadata: { type: object }
                        distance: { type: number }
                        created_at: { type: string, format: date-time }
                  query_time_ms: { type: number }

  /vectors/{id}:
    get:
      summary: Get vector by ID
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema: { type: integer }
      responses:
        '200':
          description: Vector found
        '404':
          description: Vector not found

    put:
      summary: Update vector
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema: { type: integer }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                vector: { type: array, items: { type: number } }
                metadata: { type: object }
      responses:
        '200':
          description: Vector updated

    delete:
      summary: Delete vector
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema: { type: integer }
      responses:
        '204':
          description: Vector deleted

  /vectors/stats:
    get:
      summary: Collection statistics
      security:
        - BearerAuth: []
      responses:
        '200':
          description: Statistics
          content:
            application/json:
              schema:
                type: object
                properties:
                  total_vectors: { type: integer }
                  dimension: { type: integer }
                  index_type: { type: string }
                  disk_size_mb: { type: number }

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
```

### Python Implementation (FastAPI)
```python
# shield/integrations/pgvector_api.py
from fastapi import FastAPI, HTTPException, Depends, Security
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
import time

app = FastAPI()
security = HTTPBearer()

# Request models
class VectorInsertRequest(BaseModel):
    vector: List[float] = Field(..., min_items=1, max_items=4096)
    metadata: Optional[Dict[str, Any]] = None

class BatchVectorInsertRequest(BaseModel):
    vectors: List[VectorInsertRequest] = Field(..., min_items=1, max_items=1000)

class VectorSearchRequest(BaseModel):
    query: List[float] = Field(..., min_items=1, max_items=4096)
    limit: int = Field(10, ge=1, le=100)
    metric: str = Field("cosine", pattern="^(l2|cosine|inner_product)$")
    filter: Optional[Dict[str, Any]] = None

class VectorUpdateRequest(BaseModel):
    vector: Optional[List[float]] = None
    metadata: Optional[Dict[str, Any]] = None

# Dependency: Verify Shield token
async def verify_token(credentials: HTTPAuthorizationCredentials = Security(security)):
    from shield import IdentityProvider
    provider = IdentityProvider()
    try:
        claims = provider.verify_token(credentials.credentials)
        return claims
    except Exception:
        raise HTTPException(401, "Invalid token")

# Initialize pgvector client
from shield import PgVectorClient, PgVectorConfig

config = PgVectorConfig(
    connection_string="postgresql://user:pass@localhost/shield",
    pool_size=10,
    table_name="encrypted_embeddings",
    dimension=1536,
    index_type="hnsw"
)
client = PgVectorClient(config)

# Endpoints
@app.post("/vectors", status_code=201)
async def insert_vector(req: VectorInsertRequest, claims: dict = Depends(verify_token)):
    """Insert encrypted vector with metadata"""
    try:
        vector_id = await client.insert(
            vector=req.vector,
            metadata=req.metadata or {}
        )
        return {
            "id": vector_id,
            "created_at": time.time()
        }
    except Exception as e:
        raise HTTPException(400, str(e))

@app.post("/vectors/batch", status_code=201)
async def batch_insert_vectors(req: BatchVectorInsertRequest, claims: dict = Depends(verify_token)):
    """Batch insert up to 1000 vectors"""
    try:
        ids = []
        for item in req.vectors:
            vector_id = await client.insert(
                vector=item.vector,
                metadata=item.metadata or {}
            )
            ids.append(vector_id)

        return {
            "inserted": len(ids),
            "ids": ids
        }
    except Exception as e:
        raise HTTPException(400, str(e))

@app.post("/vectors/search")
async def search_vectors(req: VectorSearchRequest, claims: dict = Depends(verify_token)):
    """Similarity search over encrypted vectors"""
    start_time = time.time()

    try:
        # Map metric name to enum
        from shield import DistanceMetric
        metric_map = {
            "l2": DistanceMetric.L2,
            "cosine": DistanceMetric.Cosine,
            "inner_product": DistanceMetric.InnerProduct
        }

        results = await client.search_similar(
            query=req.query,
            limit=req.limit,
            metric=metric_map[req.metric],
            filter=req.filter
        )

        query_time_ms = (time.time() - start_time) * 1000

        return {
            "results": [
                {
                    "id": r.id,
                    "vector": r.vector.tolist(),
                    "metadata": r.metadata,
                    "distance": r.distance,
                    "created_at": r.created_at.isoformat()
                }
                for r in results
            ],
            "query_time_ms": round(query_time_ms, 2)
        }
    except Exception as e:
        raise HTTPException(400, str(e))

@app.get("/vectors/{vector_id}")
async def get_vector(vector_id: int, claims: dict = Depends(verify_token)):
    """Retrieve vector by ID"""
    try:
        record = await client.get(vector_id)
        if not record:
            raise HTTPException(404, "Vector not found")

        return {
            "id": record.id,
            "vector": record.vector.tolist(),
            "metadata": record.metadata,
            "created_at": record.created_at.isoformat()
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(400, str(e))

@app.put("/vectors/{vector_id}")
async def update_vector(vector_id: int, req: VectorUpdateRequest, claims: dict = Depends(verify_token)):
    """Update vector and/or metadata"""
    try:
        # Fetch existing record
        record = await client.get(vector_id)
        if not record:
            raise HTTPException(404, "Vector not found")

        # Update vector if provided
        if req.vector:
            await client.update_vector(vector_id, req.vector)

        # Update metadata if provided
        if req.metadata:
            await client.update_metadata(vector_id, req.metadata)

        return {"status": "updated"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(400, str(e))

@app.delete("/vectors/{vector_id}", status_code=204)
async def delete_vector(vector_id: int, claims: dict = Depends(verify_token)):
    """Delete vector"""
    try:
        deleted = await client.delete(vector_id)
        if not deleted:
            raise HTTPException(404, "Vector not found")
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(400, str(e))

@app.get("/vectors/stats")
async def get_stats(claims: dict = Depends(verify_token)):
    """Get collection statistics"""
    try:
        stats = await client.get_stats()
        return {
            "total_vectors": stats["count"],
            "dimension": stats["dimension"],
            "index_type": stats["index_type"],
            "disk_size_mb": stats["size_mb"]
        }
    except Exception as e:
        raise HTTPException(400, str(e))
```

### Client Example (Python)
```python
import requests
import openai

# Initialize Shield client
token = "eyJ..."  # Get from IdentityProvider

# Generate embedding from text
response = openai.Embedding.create(
    model="text-embedding-3-small",
    input="The quick brown fox jumps over the lazy dog"
)
embedding = response['data'][0]['embedding']

# Insert vector
insert_resp = requests.post(
    "https://api.example.com/vectors",
    headers={"Authorization": f"Bearer {token}"},
    json={
        "vector": embedding,
        "metadata": {
            "text": "The quick brown fox jumps over the lazy dog",
            "category": "example",
            "timestamp": "2026-02-15T12:00:00Z"
        }
    }
)
vector_id = insert_resp.json()["id"]

# Search for similar vectors
search_query = openai.Embedding.create(
    model="text-embedding-3-small",
    input="fast animals"
)['data'][0]['embedding']

search_resp = requests.post(
    "https://api.example.com/vectors/search",
    headers={"Authorization": f"Bearer {token}"},
    json={
        "query": search_query,
        "limit": 5,
        "metric": "cosine",
        "filter": {"category": "example"}
    }
)

for result in search_resp.json()["results"]:
    print(f"ID: {result['id']}, Distance: {result['distance']:.4f}")
    print(f"Text: {result['metadata']['text']}\n")
```

### Metadata Filtering (JSONB)
```python
# Filter by exact match
{"category": "product"}

# Filter by nested field
{"user.role": "admin"}

# Filter by array contains
{"tags": ["ai", "ml"]}

# Complex filter (requires SQL)
# Implement in client.search_similar() using WHERE clause:
# WHERE metadata @> '{"category": "product"}'::jsonb
# AND metadata->>'priority' = 'high'
```

### Performance Optimization
```python
# 1. Batch insertions for bulk data
batch_data = [
    {"vector": emb1, "metadata": {"text": "..."}},
    {"vector": emb2, "metadata": {"text": "..."}},
    # ... up to 1000
]
batch_resp = requests.post(
    "https://api.example.com/vectors/batch",
    headers={"Authorization": f"Bearer {token}"},
    json={"vectors": batch_data}
)

# 2. Pagination for large result sets
# Use cursor-based pagination with created_at or id
search_resp = requests.post(
    "https://api.example.com/vectors/search",
    json={
        "query": query_vector,
        "limit": 100,
        "cursor": last_id  # Start after this ID
    }
)

# 3. Cache frequently searched vectors
# Implement Redis cache for hot vectors
```

### Testing Strategy
1. Unit tests: Request validation, token verification
2. Integration tests: PostgreSQL + pgvector extension required
3. Search accuracy tests: Compare encrypted vs plaintext search
4. Performance tests: Bulk insertion, search latency
5. Security tests: Authentication, authorization, MAC validation
6. Pagination tests: Cursor-based pagination edge cases
7. Filter tests: JSONB query validation

---
**Session Handoff** (fill when done):
- Changed: [files/functions modified]
- Causality: [what triggers what]
- Verify: [how to test this works]
- Next: [context for dependent tasks]
