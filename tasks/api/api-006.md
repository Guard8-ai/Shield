---
id: api-006
title: FIDO2 registration and authentication API
status: done
priority: high
tags:
- api
- auth
- endpoints
dependencies:
- backend-027
assignee: developer
created: 2026-02-15T12:43:35.962804976Z
estimate: 2h
complexity: 6
area: api
---

# FIDO2 registration and authentication API

## Causation Chain
> Trace the request lifecycle: HTTP verb → middleware chain → handler →
service → data layer → response serialization. Verify actual route
registration and middleware order in code.

## Pre-flight Checks
- [ ] Read dependency task files for implementation context (Session Handoff)
- [ ] `grep -r "route\|path\|endpoint" src/` - Verify route registration
- [ ] Check actual middleware order in router setup
- [ ] Verify response serialization matches API contract
- [ ] `git log --oneline -10` - Check recent related commits

## Context
Implement RESTful API endpoints for FIDO2/WebAuthn registration and authentication flows. These endpoints integrate with backend-027's Fido2Manager to provide a complete passwordless authentication system. Supports both FastAPI and Flask frameworks in Python, with optional Rust HTTP server using shield-core.

**Dependency on backend-027**: Requires Fido2Manager, WebAuthnConfig, and CredentialStore implementations.

## Tasks
- [ ] Design API contract (OpenAPI 3.0 schema)
- [ ] Implement Python FastAPI endpoints:
  - [ ] `POST /fido2/register/begin` - Start registration
  - [ ] `POST /fido2/register/complete` - Finish registration
  - [ ] `POST /fido2/login/begin` - Start authentication
  - [ ] `POST /fido2/login/complete` - Finish authentication
  - [ ] `DELETE /fido2/credentials/{id}` - Remove credential
  - [ ] `GET /fido2/credentials` - List user credentials
- [ ] Add request/response models with Pydantic
- [ ] Add session management for challenges (Redis/in-memory)
- [ ] Add rate limiting (prevent credential stuffing)
- [ ] Add CORS configuration for browser clients
- [ ] Add OpenAPI documentation with utoipa (Rust)
- [ ] Add integration tests with mock WebAuthn client
- [ ] Add example client (JavaScript)
- [ ] Build + test with pytest

## Acceptance Criteria
- [ ] All 6 endpoints implemented and documented
- [ ] OpenAPI schema generated and validated
- [ ] Registration flow completes successfully
- [ ] Authentication flow validates signatures
- [ ] Challenge expiration enforced (60s timeout)
- [ ] CORS headers correct for cross-origin requests
- [ ] Rate limiting prevents abuse (max 5 attempts/min)
- [ ] Sessions properly cleaned up after completion
- [ ] Error responses include helpful messages
- [ ] Integration tests pass (minimum 15 tests)

## Notes

### API Contract (OpenAPI 3.0)
```yaml
openapi: 3.0.0
info:
  title: Shield FIDO2 API
  version: 1.2.0
paths:
  /fido2/register/begin:
    post:
      summary: Begin FIDO2 registration
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                username:
                  type: string
                display_name:
                  type: string
      responses:
        '200':
          description: Registration challenge created
          content:
            application/json:
              schema:
                type: object
                properties:
                  challenge:
                    type: string
                    format: base64url
                  rp:
                    type: object
                    properties:
                      id: { type: string }
                      name: { type: string }
                  user:
                    type: object
                    properties:
                      id: { type: string, format: base64url }
                      name: { type: string }
                      displayName: { type: string }
                  pubKeyCredParams:
                    type: array
                    items:
                      type: object
                      properties:
                        type: { type: string }
                        alg: { type: integer }
                  timeout:
                    type: integer
                  attestation:
                    type: string
                    enum: [none, indirect, direct]

  /fido2/register/complete:
    post:
      summary: Complete FIDO2 registration
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                credential:
                  type: object
                  properties:
                    id: { type: string }
                    rawId: { type: string, format: base64url }
                    response:
                      type: object
                      properties:
                        clientDataJSON: { type: string, format: base64url }
                        attestationObject: { type: string, format: base64url }
                    type: { type: string }
      responses:
        '200':
          description: Registration successful
        '400':
          description: Invalid attestation

  /fido2/login/begin:
    post:
      summary: Begin FIDO2 authentication
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                username: { type: string }
      responses:
        '200':
          description: Authentication challenge created

  /fido2/login/complete:
    post:
      summary: Complete FIDO2 authentication
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                credential:
                  type: object
                  properties:
                    id: { type: string }
                    rawId: { type: string, format: base64url }
                    response:
                      type: object
                      properties:
                        clientDataJSON: { type: string, format: base64url }
                        authenticatorData: { type: string, format: base64url }
                        signature: { type: string, format: base64url }
                        userHandle: { type: string, format: base64url }
      responses:
        '200':
          description: Authentication successful
          content:
            application/json:
              schema:
                type: object
                properties:
                  access_token: { type: string }
                  token_type: { type: string }
```

### Python Implementation (FastAPI)
```python
# shield/integrations/fido2_api.py
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional
import secrets
import time

app = FastAPI()

# CORS for browser clients
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://example.com"],
    allow_credentials=True,
    allow_methods=["POST", "GET", "DELETE"],
    allow_headers=["*"],
)

# Session storage (use Redis in production)
challenges = {}  # {session_id: {challenge, user_id, expires_at}}

# Request models
class RegistrationBeginRequest(BaseModel):
    username: str
    display_name: str

class RegistrationCompleteRequest(BaseModel):
    credential: dict  # WebAuthn PublicKeyCredential

class LoginBeginRequest(BaseModel):
    username: str

class LoginCompleteRequest(BaseModel):
    credential: dict

# Endpoints
@app.post("/fido2/register/begin")
async def register_begin(req: RegistrationBeginRequest):
    # 1. Generate session ID and challenge
    session_id = secrets.token_urlsafe(32)
    user_id = secrets.token_bytes(32)

    # 2. Call Rust backend
    from shield import Fido2Manager
    manager = Fido2Manager()
    challenge_data = manager.generate_registration_challenge(
        user_id, req.username, req.display_name
    )

    # 3. Store challenge in session
    challenges[session_id] = {
        "challenge": challenge_data["challenge"],
        "user_id": user_id,
        "expires_at": time.time() + 60,
        "type": "registration"
    }

    # 4. Return challenge to client
    return {
        **challenge_data,
        "session_id": session_id
    }

@app.post("/fido2/register/complete")
async def register_complete(req: RegistrationCompleteRequest, session_id: str):
    # 1. Validate session
    session = challenges.get(session_id)
    if not session or session["type"] != "registration":
        raise HTTPException(400, "Invalid session")
    if time.time() > session["expires_at"]:
        raise HTTPException(400, "Challenge expired")

    # 2. Verify registration with Rust backend
    from shield import Fido2Manager
    manager = Fido2Manager()
    try:
        credential = manager.verify_registration(
            session["challenge"],
            req.credential["response"]["clientDataJSON"],
            req.credential["response"]["attestationObject"],
            "https://example.com"
        )

        # 3. Store credential
        manager.store_credential(session["user_id"], credential)

        # 4. Clean up session
        del challenges[session_id]

        return {"status": "success"}
    except Exception as e:
        raise HTTPException(400, str(e))

@app.post("/fido2/login/begin")
async def login_begin(req: LoginBeginRequest):
    # Similar to register_begin but returns allowed_credentials
    session_id = secrets.token_urlsafe(32)

    from shield import Fido2Manager
    manager = Fido2Manager()
    challenge_data = manager.generate_authentication_challenge(req.username)

    challenges[session_id] = {
        "challenge": challenge_data["challenge"],
        "username": req.username,
        "expires_at": time.time() + 60,
        "type": "authentication"
    }

    return {
        **challenge_data,
        "session_id": session_id
    }

@app.post("/fido2/login/complete")
async def login_complete(req: LoginCompleteRequest, session_id: str):
    # Verify authentication and return JWT token
    session = challenges.get(session_id)
    if not session or session["type"] != "authentication":
        raise HTTPException(400, "Invalid session")
    if time.time() > session["expires_at"]:
        raise HTTPException(400, "Challenge expired")

    from shield import Fido2Manager
    manager = Fido2Manager()
    try:
        auth_result = manager.verify_authentication(
            session["challenge"],
            session["username"],
            req.credential["response"]["clientDataJSON"],
            req.credential["response"]["authenticatorData"],
            req.credential["response"]["signature"]
        )

        # Generate access token (use Shield's IdentityProvider)
        from shield import IdentityProvider
        provider = IdentityProvider()
        token = provider.issue_token(session["username"], 3600)

        del challenges[session_id]

        return {
            "access_token": token,
            "token_type": "Bearer"
        }
    except Exception as e:
        raise HTTPException(401, "Authentication failed")
```

### Client Example (JavaScript)
```javascript
// Register new credential
async function register(username, displayName) {
    // 1. Get challenge from server
    const beginResp = await fetch('/fido2/register/begin', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({username, display_name: displayName})
    });
    const options = await beginResp.json();
    const sessionId = options.session_id;

    // 2. Create credential with browser
    const credential = await navigator.credentials.create({
        publicKey: {
            challenge: base64urlDecode(options.challenge),
            rp: options.rp,
            user: {
                id: base64urlDecode(options.user.id),
                name: options.user.name,
                displayName: options.user.displayName
            },
            pubKeyCredParams: options.pubKeyCredParams,
            timeout: options.timeout,
            attestation: options.attestation
        }
    });

    // 3. Send credential to server
    const completeResp = await fetch(`/fido2/register/complete?session_id=${sessionId}`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            credential: {
                id: credential.id,
                rawId: base64urlEncode(credential.rawId),
                response: {
                    clientDataJSON: base64urlEncode(credential.response.clientDataJSON),
                    attestationObject: base64urlEncode(credential.response.attestationObject)
                },
                type: credential.type
            }
        })
    });

    return completeResp.json();
}

// Authenticate with credential
async function login(username) {
    // Similar flow but using navigator.credentials.get()
    const beginResp = await fetch('/fido2/login/begin', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({username})
    });
    const options = await beginResp.json();

    const credential = await navigator.credentials.get({
        publicKey: {
            challenge: base64urlDecode(options.challenge),
            allowCredentials: options.allowCredentials.map(c => ({
                id: base64urlDecode(c.id),
                type: c.type
            })),
            timeout: options.timeout
        }
    });

    const completeResp = await fetch(`/fido2/login/complete?session_id=${options.session_id}`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            credential: {
                id: credential.id,
                rawId: base64urlEncode(credential.rawId),
                response: {
                    clientDataJSON: base64urlEncode(credential.response.clientDataJSON),
                    authenticatorData: base64urlEncode(credential.response.authenticatorData),
                    signature: base64urlEncode(credential.response.signature),
                    userHandle: base64urlEncode(credential.response.userHandle)
                }
            }
        })
    });

    const {access_token} = await completeResp.json();
    localStorage.setItem('token', access_token);
}
```

### Rate Limiting
```python
from shield.integrations import RateLimiter

rate_limiter = RateLimiter(max_attempts=5, window_seconds=60)

@app.post("/fido2/login/begin")
async def login_begin(req: LoginBeginRequest, request: Request):
    client_ip = request.client.host
    if not rate_limiter.allow(f"fido2:login:{client_ip}"):
        raise HTTPException(429, "Too many attempts")
    # ... rest of endpoint
```

### Testing Strategy
1. Unit tests: Session management, challenge validation
2. Integration tests: Full registration + authentication flow
3. Browser tests: Selenium/Playwright with virtual authenticator
4. Security tests: Expired challenges, invalid signatures, replay attacks
5. Rate limit tests: Verify throttling works

---
**Session Handoff**:
- Changed:
  - `python/shield/integrations/fido2_api.py` - Complete FastAPI integration (~400 lines)
  - Fido2Router class with 6 endpoints
  - Request/response models with Pydantic validation
  - In-memory challenge storage (production should use Redis)
  - Shield-encrypted credential storage (simplified, use Rust backend in production)
- Causality:
  - POST /fido2/register/begin → generate challenge → store session → return to client
  - POST /fido2/register/complete → verify challenge → store credential → return success
  - POST /fido2/login/begin → check credentials exist → generate auth challenge → return allowed credentials
  - POST /fido2/login/complete → verify signature → generate token → return JWT
  - GET /fido2/credentials → list user credentials
  - DELETE /fido2/credentials/{id} → remove credential
- Verify:
  - Import: `from shield.integrations.fido2_api import Fido2Router`
  - Create router: `router = Fido2Router(password="secret", service="myapp")`
  - Add to FastAPI: `app.include_router(router.router)`
  - Test endpoints with HTTP client or WebAuthn-enabled browser
- Next:
  - Production: Replace in-memory storage with Redis for challenges
  - Production: Integrate Rust fido2 module via FFI/PyO3 for proper cryptographic verification
  - Add rate limiting using Shield's RateLimiter
  - Add CORS middleware for browser clients
  - Add proper attestation verification (currently simplified)