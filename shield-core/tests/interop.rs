//! Cross-language interoperability tests.
//!
//! Verifies Rust implementation matches Python byte-for-byte.

use shield_core::Shield;

/// Test vectors from Python implementation.
/// Generated by: python3 tests/interop.py
mod test_vectors {
    /// Password used for testing
    pub const PASSWORD: &str = "test_password";
    /// Service name
    pub const SERVICE: &str = "test.service";
    /// Expected derived key (PBKDF2-SHA256, 100k rounds)
    pub const KEY_HEX: &str = "4f1f99907e7f158dd282599d8a1be05b74d385eb79ba35971d884cc4ef172e87";
    /// Test nonce (0x00..0x0F)
    pub const NONCE_HEX: &str = "000102030405060708090a0b0c0d0e0f";
    /// Expected keystream for 64 bytes
    pub const KEYSTREAM_64_HEX: &str = "94118691ec7e755375aa0764485140d3b2fa0651805c2cd516ea6fa5dc3e9f8a40573b4b2ce1c234075038557ebe175127bdb65bd8d8c2f379a82c5a209c69ed";
}

#[test]
fn test_key_derivation_matches_python() {
    let shield = Shield::new(test_vectors::PASSWORD, test_vectors::SERVICE);
    let key = shield.key();
    let expected = hex::decode(test_vectors::KEY_HEX).unwrap();

    assert_eq!(
        key.as_slice(),
        expected.as_slice(),
        "Key derivation mismatch:\n  Rust:   {}\n  Python: {}",
        hex::encode(key),
        test_vectors::KEY_HEX
    );
}

#[test]
fn test_keystream_matches_python() {
    // Use the same key and nonce as Python test vectors
    let key = hex::decode(test_vectors::KEY_HEX).unwrap();
    let nonce = hex::decode(test_vectors::NONCE_HEX).unwrap();

    // Generate keystream using the same algorithm
    let mut keystream = Vec::new();
    for i in 0..2 {
        let counter = (i as u32).to_le_bytes();
        let mut data = Vec::new();
        data.extend_from_slice(&key);
        data.extend_from_slice(&nonce);
        data.extend_from_slice(&counter);

        let hash = ring::digest::digest(&ring::digest::SHA256, &data);
        keystream.extend_from_slice(hash.as_ref());
    }

    let expected = hex::decode(test_vectors::KEYSTREAM_64_HEX).unwrap();

    assert_eq!(
        keystream,
        expected,
        "Keystream mismatch:\n  Rust:   {}\n  Python: {}",
        hex::encode(&keystream),
        test_vectors::KEYSTREAM_64_HEX
    );
}

#[test]
fn test_encrypt_decrypt_roundtrip() {
    let shield = Shield::new("password", "service");
    let plaintext = b"Hello, EXPTIME-secure world!";

    let encrypted = shield.encrypt(plaintext).unwrap();
    let decrypted = shield.decrypt(&encrypted).unwrap();

    assert_eq!(plaintext.as_slice(), decrypted.as_slice());
}

#[test]
fn test_ciphertext_format() {
    let shield = Shield::new("password", "service");
    let encrypted = shield.encrypt(b"test").unwrap();

    // Format: nonce(16) + counter(8) + plaintext(4) + mac(16) = 44 bytes
    assert_eq!(encrypted.len(), 44, "Ciphertext should be 44 bytes");
}

#[test]
fn test_different_passwords_isolation() {
    let shield1 = Shield::new("password1", "service");
    let shield2 = Shield::new("password2", "service");

    let plaintext = b"secret data";
    let encrypted = shield1.encrypt(plaintext).unwrap();

    // Should fail to decrypt with wrong password
    assert!(
        shield2.decrypt(&encrypted).is_err(),
        "Should not decrypt with wrong password"
    );
}

#[test]
fn test_different_services_isolation() {
    let shield1 = Shield::new("password", "service1");
    let shield2 = Shield::new("password", "service2");

    let plaintext = b"secret data";
    let encrypted = shield1.encrypt(plaintext).unwrap();

    // Should fail to decrypt with wrong service
    assert!(
        shield2.decrypt(&encrypted).is_err(),
        "Should not decrypt with wrong service"
    );
}

#[test]
fn test_tamper_detection() {
    let shield = Shield::new("password", "service");
    let mut encrypted = shield.encrypt(b"secret data").unwrap();

    // Tamper with ciphertext
    encrypted[20] ^= 0xFF;

    assert!(
        shield.decrypt(&encrypted).is_err(),
        "Should detect tampering"
    );
}
